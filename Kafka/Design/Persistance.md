# Persistența

**Nu vă temeți de sistemul de fișiere!**

Kafka depinde în mod semnificativ de sistemul de fișiere pentru stocarea și memorarea mesajelor. Există o percepție generală că "discurile sunt lente", ceea ce îi face pe oameni să fie sceptici că o structură persistentă poate oferi performanțe competitive. De fapt, discurile sunt atât mult mai lente, cât și mult mai rapide decât oamenii se așteaptă, în funcție de modul în care sunt utilizate; și o structură de disc proiectată corespunzător poate fi adesea la fel de rapidă ca rețeaua.

Aspectul cheie despre performanța discului este că throughput-ul hard disk-urilor s-a îndepărtat de latența unei căutări pe disc în ultimul deceniu. Ca rezultat, performanța scrierilor lineare pe o configurație JBOD cu șase unități SATA RAID-5 la 7200rpm este de aproximativ 600MB/sec, dar performanța scrierilor aleatoare este doar de aproximativ 100k/sec - o diferență de peste 6000X. Aceste citiri și scrieri lineare sunt cele mai previzibile modele de utilizare și sunt puternic optimizate de sistemul de operare. Un sistem de operare modern oferă tehnici de citire în avans și scriere în spate care preiau datele în blocuri mari și grupuri de scrieri logice mai mici în scrieri fizice mari. O discuție mai detaliată despre această problemă poate fi găsită în acest articol ACM Queue; ei constată că accesul secvențial la disc poate în unele cazuri fi mai rapid decât accesul aleator la memorie!

Pentru a compensa această divergență de performanță, sistemele de operare moderne au devenit tot mai agresive în utilizarea memoriei principale pentru memorarea în cache a discului. Un sistem de operare modern va redirecționa cu bucurie întreaga memorie liberă către memorarea în cache a discului, cu puține penalități de performanță atunci când memoria este recuperată. Toate citirile și scrierile de pe disc vor trece prin acest cache unificat. Această caracteristică nu poate fi ușor dezactivată fără a utiliza I/O direct, astfel încât chiar dacă un proces menține un cache în proces al datelor, aceste date vor fi probabil duplicate în cache-ul paginii OS-ului, stocând practic totul de două ori.

În plus, construim pe JVM, iar oricine a petrecut ceva timp cu utilizarea memoriei Java știe două lucruri:

1. Suprapunerea memoriei obiectelor este foarte mare, dublând adesea dimensiunea datelor stocate (sau mai rău).
2. Colectarea deșeurilor Java devine tot mai complicată și lentă pe măsură ce datele în-heap cresc.

Ca rezultat al acestor factori, utilizarea sistemului de fișiere și dependența de pagecache sunt superioare menținerii unui cache în memorie sau alte structuri - avem cel puțin dublul cache-ului disponibil prin accesul automat la toată memoria liberă și probabil dublăm din nou prin stocarea unei structuri compacte de octeți în loc de obiecte individuale. A face acest lucru va duce la un cache de până la 28-30GB pe o mașină de 32GB fără penalități GC. Mai mult, acest cache va rămâne cald chiar dacă serviciul este repornit, în timp ce cache-ul în proces va trebui reconstruit în memorie (ceea ce pentru un cache de 10GB poate dura 10 minute) sau va trebui să înceapă cu un cache complet rece (ceea ce înseamnă probabil o performanță inițială groaznică). Acest lucru simplifică foarte mult codul, deoarece toată logica pentru menținerea coerenței între cache și sistemul de fișiere este acum în OS, care are tendința să facă acest lucru mai eficient și mai corect decât încercările sporadice în proces. Dacă utilizarea discului dvs. favorizează citirile lineare, atunci citirea în avans populează eficient acest cache cu date utile la fiecare citire de pe disc.

Acest lucru sugerează un design care este foarte simplu: în loc să menținem cât mai mult posibil în memorie și să îl eliminăm complet în sistemul de fișiere într-un moment de panică când rămânem fără spațiu, inversăm asta. Toate datele sunt scrise imediat într-un jurnal persistent pe sistemul de fișiere fără a fi nevoie de scriere pe disc. Practic, acest lucru înseamnă doar că este transferat în pagecache-ul kernelului.

**Timp Constant Sufice**

Structurile de date persistente utilizate în sistemele de mesagerie sunt adesea o coadă pe consumator cu o structură de date de acces aleatoriu asociată, cum ar fi un BTree sau alte structuri de date de acces aleatoriu de uz general pentru a menține metadatele despre mesaje. BTree-urile sunt cele mai versatile structuri de date disponibile și fac posibil să susținem o varietate largă de semantici tranzacționale și netranzacționale în sistemul de mesagerie. Cu toate acestea, acestea vin cu un cost destul de mare: operațiunile BTree sunt O(log N). În mod normal, O(log N) este considerat esențial echivalent cu timp constant, dar acest lucru nu este adevărat pentru operațiile pe disc. Căutările pe disc vin la 10 ms fiecare, iar fiecare disc poate face doar o căutare la un moment dat, astfel că paralelismul este limitat. Prin urmare, chiar și un număr mic de căutări pe disc duce la o suprancărcare foarte mare. Deoarece sistemele de stocare amestecă operațiuni foarte rapide în cache cu operațiuni fizice foarte lente pe disc, performanța observată a structurilor arborescente este adesea superlineară odată cu creșterea datelor cu o memorie cache fixă - adică dublarea datelor face lucrurile mult mai rele decât de două ori mai încet.

Intuitiv, o coadă persistentă ar putea fi construită pe citiri și adăugări simple la fișiere, așa cum este adesea cazul în soluțiile de înregistrare. Această structură are avantajul că toate operațiunile sunt O(1) și citirile nu blochează scrierile sau reciproc. Acest lucru are avantaje evidente de performanță, deoarece performanța este complet decuplată de dimensiunea datelor - un singur server poate profita acum de un număr de unități SATA ieftine, cu viteză redusă de rotație, de 1+TB. Deși au o performanță slabă pentru căutări, aceste unități au performanțe acceptabile pentru citiri și scrieri mari și vin la 1/3 din preț și 3x capacitate.

Având acces la spațiu pe disc virtual nelimitat fără nicio penalitate de performanță înseamnă că putem oferi unele caracteristici pe care de obicei nu le găsiți într-un sistem de mesagerie. De exemplu, în Kafka, în loc să încercăm să ștergem mesajele imediat ce sunt consumate, putem reține mesajele pentru un perioadă relativ lungă (să zicem o săptămână). Acest lucru conduce la o mare flexibilitate pentru consumatori, așa cum vom descrie.
